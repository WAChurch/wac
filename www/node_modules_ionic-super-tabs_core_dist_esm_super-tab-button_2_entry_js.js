"use strict";
(self["webpackChunkapp"] = self["webpackChunkapp"] || []).push([["node_modules_ionic-super-tabs_core_dist_esm_super-tab-button_2_entry_js"],{

/***/ 2848:
/*!**********************************************************************************!*\
  !*** ./node_modules/@ionic-super-tabs/core/dist/esm/super-tab-button_2.entry.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "super_tab_button": () => (/* binding */ SuperTabButtonComponent),
/* harmony export */   "super_tabs_toolbar": () => (/* binding */ SuperTabsToolbarComponent)
/* harmony export */ });
/* harmony import */ var C_FunerCien_WAC_HWAC_med_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator */ 2783);
/* harmony import */ var _index_a34c410e_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index-a34c410e.js */ 797);
/* harmony import */ var _utils_640d2cf5_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils-640d2cf5.js */ 9886);



const superTabButtonComponentCss = ":host{-ms-flex:1 0 0px;flex:1 0 0;cursor:pointer;position:relative;max-width:100%;overflow:hidden;display:-ms-flexbox;display:flex;-ms-flex-flow:column nowrap;flex-flow:column nowrap;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-transform:translate3d(0, 0, 0);transform:translate3d(0, 0, 0);height:72px;padding:0 24px;-webkit-touch-callout:none;-webkit-user-select:none;-webkit-text-size-adjust:none;-webkit-tap-highlight-color:rgba(0, 0, 0, 0);-webkit-font-smoothing:antialiased}:host ion-label,:host ion-icon,:host ::slotted(ion-label),:host ::slotted(ion-icon){-webkit-transition-property:all;transition-property:all;-webkit-transition-duration:300ms;transition-duration:300ms;-webkit-transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);-webkit-transition-delay:0s;transition-delay:0s;-webkit-box-sizing:content-box !important;box-sizing:content-box !important;-webkit-user-select:none;-webkit-text-size-adjust:none;-webkit-tap-highlight-color:rgba(0, 0, 0, 0);-webkit-font-smoothing:antialiased}:host ion-label,:host ::slotted(ion-label){color:var(--st-label-color-inactive, var(--st-base-color-inactive));line-height:var(--st-label-line-height, 14px);height:var(--st-label-height, 14px);font-size:var(--st-label-font-size, 14px);text-transform:var(--st-label-text-transform, uppercase);font-weight:var(--st-label-font-weight, 500);padding-bottom:var(--st-label-padding-bottom, 16px)}:host ion-icon,:host ::slotted(ion-icon){color:var(--st-icon-color-inactive, var(--st-base-color-inactive));fill:var(--st-icon-color-inactive, var(--st-base-color-inactive));min-height:var(--st-icon-size, 24px);min-width:var(--st-icon-size, 24px);font-size:var(--st-icon-size, 24px);padding-top:12px}@media (hover: hover){:host(:hover){background:rgba(var(--ion-color-contrast-rgb), 0.04)}}:host(.active) ion-label,:host(.active) ion-icon,:host(.active) ::slotted(ion-label),:host(.active) ::slotted(ion-icon){-webkit-transition-delay:75ms;transition-delay:75ms}:host(.active) ion-label,:host(.active) ::slotted(ion-label){color:var(--st-label-color-active, var(--st-base-color-active))}:host(.active) ion-icon,:host(.active) ::slotted(ion-icon){color:var(--st-icon-color-active, var(--st-base-color-active));fill:var(--st-icon-color-active, var(--st-base-color-active))}:host(.icon-only),:host(.label-only){height:48px;-ms-flex-pack:center;justify-content:center}:host(.scrollableContainer){-ms-flex-positive:0;flex-grow:0;-ms-flex-preferred-size:auto;flex-basis:auto;min-width:90px;max-width:360px}::slotted{-ms-flex-negative:1;flex-shrink:1}:host(.label-only) ion-label,:host(.label-only) ::slotted(ion-label){padding-bottom:0}:host(.icon-only) ion-icon,:host(.icon-only) ::slotted(ion-icon){padding-top:0}";
const maxRetryAttempts = 1e3;

class SuperTabButtonComponent {
  constructor(hostRef) {
    (0,_index_a34c410e_js__WEBPACK_IMPORTED_MODULE_1__.r)(this, hostRef);
    /**
     * Whether the button is disabled
     */

    this.disabled = false;
    /** @internal */

    this.scrollableContainer = false;
    this.retryAttempts = 0;
  }

  componentDidLoad() {
    this.indexChildren();
    this.initCmp();
  }

  initCmp() {
    if (!this.el || !this.el.shadowRoot) {
      if (++this.retryAttempts < maxRetryAttempts) {
        requestAnimationFrame(() => this.initCmp());
        return;
      }
    }

    if (!this.label && !this.icon) {
      this.indexChildren();
    }

    const slot = this.el.shadowRoot.querySelector('slot');
    slot.addEventListener('slotchange', () => {
      this.indexChildren();
    });
  }

  indexChildren() {
    this.label = this.el.querySelector('ion-label');
    this.icon = this.el.querySelector('ion-icon');
  }

  render() {
    return (0,_index_a34c410e_js__WEBPACK_IMPORTED_MODULE_1__.h)(_index_a34c410e_js__WEBPACK_IMPORTED_MODULE_1__.H, {
      role: "button",
      "aria-label": this.label ? this.label.innerText : false,
      "aria-disabled": this.disabled ? 'true' : false,
      "aria-selected": this.active ? 'true' : 'false',
      class: {
        'ion-activatable': !this.disabled,
        'ion-focusable': !this.disabled,
        'icon-only': !!this.icon && !this.label,
        'label-only': !!this.label && !this.icon,
        active: Boolean(this.active),
        scrollableContainer: this.scrollableContainer
      }
    }, (0,_index_a34c410e_js__WEBPACK_IMPORTED_MODULE_1__.h)("slot", null), (0,_index_a34c410e_js__WEBPACK_IMPORTED_MODULE_1__.h)("ion-ripple-effect", {
      type: "unbounded"
    }));
  }

  get el() {
    return (0,_index_a34c410e_js__WEBPACK_IMPORTED_MODULE_1__.g)(this);
  }

}

SuperTabButtonComponent.style = superTabButtonComponentCss;
const superTabsToolbarComponentCss = ":host{-ms-flex:0 1 auto;flex:0 1 auto;display:block;width:100%;-webkit-transform:translate3d(0, 0, 0);transform:translate3d(0, 0, 0);position:relative;background:var(--super-tabs-toolbar-background, var(--ion-color-base));overflow:visible;-webkit-box-sizing:border-box;box-sizing:border-box;pointer-events:auto;-ms-touch-action:pan-x;touch-action:pan-x;z-index:2;-ms-flex-order:-1;order:-1;-webkit-user-select:none;-webkit-touch-callout:none;-webkit-text-size-adjust:none;-webkit-tap-highlight-color:rgba(0, 0, 0, 0);-webkit-font-smoothing:antialiased}:host .buttons-container{display:-ms-flexbox;display:flex;-ms-flex-flow:row nowrap;flex-flow:row nowrap;width:100%;-webkit-transform:translate3d(0, 0, 0);transform:translate3d(0, 0, 0);overflow:hidden}:host(:not([no-border])):after{left:0;bottom:-8px;background-position:left 0 top 0;position:absolute;width:100%;height:8px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAIBAMAAAACWGKkAAAAFVBMVEUAAAAAAAAAAAAAAAAAAAAAAAAAAAASAQCkAAAAB3RSTlMFTEIzJBcOYhQUIwAAAB9JREFUCNdjEIQCBiUoYDCGAgYXKGAIhQKGNChgwAAAorMLKSCkL40AAAAASUVORK5CYII=);background-repeat:repeat-x;content:\"\";z-index:3;-webkit-transform:translate3d(0, 0, 0);transform:translate3d(0, 0, 0)}:host([scrollable]) .buttons-container{will-change:scroll-position}:host([scrollable][scrollable-padding]) .buttons-container{padding-left:var(--st-scrollable-toolbar-padding-left, 52px);width:calc(100% - var(--st-scrollable-toolbar-padding-left, $st-scrollable-toolbar-padding-left))}";

class SuperTabsToolbarComponent {
  constructor(hostRef) {
    (0,_index_a34c410e_js__WEBPACK_IMPORTED_MODULE_1__.r)(this, hostRef);
    /**
     * Whether to show the indicator. Defaults to `true`
     */

    this.showIndicator = true;
    /**
     * Background color. Defaults to `'primary'`
     */

    this.color = 'primary';
    /**
     * Whether the toolbar is scrollable. Defaults to `false`.
     */

    this.scrollable = false;
    /**
     * If scrollable is set to true, there will be an added padding
     * to the left of the buttons.
     *
     * Setting this property to false will remove that padding.
     *
     * The padding is also configurable via a CSS variable.
     */

    this.scrollablePadding = true;
    this.buttons = [];
    this.activeTabIndex = 0;
    this.touchStartTs = 0;
    this.lastClickTs = 0;
    this.leftThreshold = 0;
    this.rightThreshold = 0;
    this.hostCls = {};
    this.buttonClick = (0,_index_a34c410e_js__WEBPACK_IMPORTED_MODULE_1__.c)(this, "buttonClick", 7);
  }

  componentDidLoad() {
    var _this = this;

    return (0,C_FunerCien_WAC_HWAC_med_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      _this.setHostCls();

      yield _this.queryButtons();
      _this.slot = _this.el.shadowRoot.querySelector('slot');

      _this.slot.addEventListener('slotchange', _this.onSlotChange.bind(_this));

      _this.updateWidth();

      requestAnimationFrame(() => {
        _this.setActiveTab(_this.activeTabIndex, true, false);
      });
    })();
  }

  componentWillUpdate() {
    this.debug('componentWillUpdate');
    this.updateThresholds();
  }

  componentDidRender() {
    this.updateWidth();
  }

  updateWidth() {
    const cr = this.el.getBoundingClientRect();
    this.width = Math.round(cr.width * 100) / 100;
    this.offsetLeft = cr.left;
  }
  /** @internal */


  setActiveTab(index, align, animate) {
    index = Math.max(0, Math.min(Math.round(index), this.buttons.length - 1));
    this.debug('setActiveTab', index, align, animate);
    this.activeTabIndex = index;
    this.markButtonActive(this.buttons[index]);

    if (align) {
      this.alignIndicator(index, animate);
    }

    return Promise.resolve();
  }
  /** @internal */


  setSelectedTab(index, animate) {
    this.alignIndicator(index, animate);
    return Promise.resolve();
  }
  /** @internal */


  moveContainer(scrollX, animate) {
    if (!this.buttonsContainerEl) {
      this.debug('moveContainer called before this.buttonsContainerEl was defined');
      return Promise.resolve();
    }

    (0,_utils_640d2cf5_js__WEBPACK_IMPORTED_MODULE_2__.s)(this.buttonsContainerEl, scrollX, 0, this.config.nativeSmoothScroll, animate ? this.config.transitionDuration : 0);
    return Promise.resolve();
  }

  getButtonFromEv(ev) {
    let button = ev.target;
    const tag = button.tagName.toLowerCase();

    if (tag !== 'super-tab-button') {
      if (tag === 'super-tabs-toolbar') {
        return;
      }

      button = button.closest('super-tab-button');
    }

    return button;
  }

  onClick(ev) {
    if (!ev || !ev.target) {
      this.debug('Got a click event with no target!', ev);
      return;
    }

    if (Date.now() - this.touchStartTs <= 150) {
      return;
    }

    const button = this.getButtonFromEv(ev);

    if (!button) {
      return;
    }

    this.onButtonClick(button);
  }

  onButtonClick(button) {
    if (!button || button.disabled) {
      return;
    }

    this.lastClickTs = Date.now();
    this.setActiveTab(button.index, true, true);
    this.buttonClick.emit(button);
  }

  onTouchStart(ev) {
    var _this2 = this;

    return (0,C_FunerCien_WAC_HWAC_med_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      if (!_this2.scrollable) {
        return;
      }

      _this2.debug('onTouchStart', ev);

      const coords = (0,_utils_640d2cf5_js__WEBPACK_IMPORTED_MODULE_2__.p)(ev);
      const vw = _this2.width;

      if (coords.x < _this2.leftThreshold || coords.x > vw - _this2.rightThreshold) {
        // ignore this gesture, it started in the side menu touch zone
        return;
      }

      _this2.touchStartTs = Date.now();
      _this2.initialCoords = coords;
      _this2.lastPosX = coords.x;
    })();
  }

  onTouchMove(ev) {
    var _this3 = this;

    return (0,C_FunerCien_WAC_HWAC_med_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      if (!_this3.buttonsContainerEl || !_this3.scrollable || !_this3.initialCoords || typeof _this3.lastPosX !== 'number') {
        return;
      }

      const coords = (0,_utils_640d2cf5_js__WEBPACK_IMPORTED_MODULE_2__.p)(ev);

      if (!_this3.isDragging) {
        const shouldCapture = (0,_utils_640d2cf5_js__WEBPACK_IMPORTED_MODULE_2__.c)(coords, _this3.initialCoords, _this3.config);

        if (!shouldCapture) {
          if (Math.abs(coords.y - _this3.initialCoords.y) > 100) {
            _this3.initialCoords = void 0;
            _this3.lastPosX = void 0;
          }

          return;
        } // gesture is good, let's capture all next onTouchMove events


        _this3.isDragging = true;
      }

      if (!_this3.isDragging) {
        return;
      }

      ev.stopImmediatePropagation(); // get delta X

      const deltaX = _this3.lastPosX - coords.x;

      if (deltaX === 0) {
        return;
      } // update last X value


      _this3.lastPosX = coords.x;
      requestAnimationFrame(() => {
        if (!_this3.isDragging) {
          // when swiping fast; this might run after we're already done scrolling
          // which leads to "choppy" animations since this instantly scrolls to location
          return;
        } // scroll container


        const scrollX = (0,_utils_640d2cf5_js__WEBPACK_IMPORTED_MODULE_2__.g)(_this3.buttonsContainerEl, _this3.buttonsContainerEl.clientWidth, deltaX);

        if (scrollX === _this3.buttonsContainerEl.scrollLeft) {
          return;
        }

        _this3.buttonsContainerEl.scroll(scrollX, 0);
      });
    })();
  }

  onTouchEnd(ev) {
    var _this4 = this;

    return (0,C_FunerCien_WAC_HWAC_med_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      var _a, _b;

      if (_this4.lastClickTs < _this4.touchStartTs && Date.now() - _this4.touchStartTs <= 150) {
        const coords = (0,_utils_640d2cf5_js__WEBPACK_IMPORTED_MODULE_2__.p)(ev);

        if (Math.abs(coords.x - ((_a = _this4.initialCoords) === null || _a === void 0 ? void 0 : _a.x)) < ((_b = _this4.config) === null || _b === void 0 ? void 0 : _b.dragThreshold)) {
          const button = _this4.getButtonFromEv(ev);

          if (!button) {
            return;
          }

          _this4.onButtonClick(button);
        }
      }

      _this4.isDragging = false;
      _this4.initialCoords = void 0;
      _this4.lastPosX = void 0;
    })();
  }

  onColorUpdate() {
    var _this5 = this;

    return (0,C_FunerCien_WAC_HWAC_med_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      _this5.setHostCls();
    })();
  }

  setHostCls() {
    const cls = {};

    if (typeof this.color === 'string' && this.color.trim().length > 0) {
      cls['ion-color-' + this.color.trim()] = true;
    }

    this.hostCls = cls;
  }

  onSlotChange() {
    var _this6 = this;

    return (0,C_FunerCien_WAC_HWAC_med_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      _this6.debug('onSlotChange');

      _this6.updateWidth();

      yield _this6.queryButtons();
      yield _this6.setActiveTab(_this6.activeTabIndex, true);
    })();
  }

  queryButtons() {
    var _this7 = this;

    return (0,C_FunerCien_WAC_HWAC_med_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      _this7.debug('Querying buttons');

      const buttons = Array.from(_this7.el.querySelectorAll('super-tab-button'));
      yield Promise.all(buttons.map(b => b.componentOnReady()));

      if (buttons) {
        for (let i = 0; i < buttons.length; i++) {
          const button = buttons[i];
          button.index = i;
          button.scrollableContainer = _this7.scrollable;
          button.active = _this7.activeTabIndex === i;

          if (button.active) {
            _this7.activeButton = button;
          }
        }
      }

      _this7.buttons = buttons;
    })();
  }

  updateThresholds() {
    if (!this.config) {
      return;
    }

    if (this.config.sideMenu === 'both' || this.config.sideMenu === 'left') {
      this.leftThreshold = this.config.sideMenuThreshold;
    }

    if (this.config.sideMenu === 'both' || this.config.sideMenu === 'right') {
      this.rightThreshold = this.config.sideMenuThreshold;
    }
  }

  markButtonActive(button) {
    if (!button) {
      this.debug('markButtonActive', 'button was undefined!');
      return;
    }

    if (this.activeButton) {
      this.activeButton.active = false;
    }

    button.active = true;
    this.activeButton = button;
  }

  setButtonsContainerEl(el) {
    if (el) {
      this.buttonsContainerEl = el;
    }
  }

  adjustContainerScroll(animate) {
    if (!this.buttonsContainerEl) {
      this.debug('adjustContainerScroll called before this.buttonsContainerEl was defined');
      return;
    }

    let pos;
    const ip = this.indicatorPosition;
    const iw = this.indicatorWidth;
    const mw = this.buttonsContainerEl.clientWidth;
    const sp = this.buttonsContainerEl.scrollLeft;
    const centerDelta = mw / 2 - iw / 2;
    const a = Math.floor(ip + iw + centerDelta);
    const b = Math.floor(ip - centerDelta);
    const c = Math.floor(mw + sp);

    if (a > c) {
      // we need to move the segment container to the left
      pos = ip + iw + centerDelta - mw;
    } else if (b < sp) {
      // we need to move the segment container to the right
      pos = Math.max(ip - centerDelta, 0);
      pos = pos > ip ? ip - mw + iw : pos;
    } else {
      return;
    }

    if (!animate) {
      (0,_utils_640d2cf5_js__WEBPACK_IMPORTED_MODULE_2__.s)(this.buttonsContainerEl, pos, 0, false, 50);
    } else {
      this.moveContainer(pos, animate);
    }
  }
  /**
   * Align the indicator with the selected button.
   * This will adjust the width and the position of the indicator element.
   * @param index {number} the active tab index
   * @param [animate] {boolean=false} whether to animate the transition
   */


  alignIndicator(index, animate = false) {
    var _this8 = this;

    return (0,C_FunerCien_WAC_HWAC_med_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      if (!_this8.showIndicator || !_this8.indicatorEl) {
        return;
      }

      _this8.debug('Aligning indicator', index);

      const remainder = index % 1;
      const isDragging = _this8.isDragging = remainder > 0;
      const floor = Math.floor(index),
            ceil = Math.ceil(index);
      const button = _this8.buttons[floor];

      if (!button) {
        return;
      }

      let position = button.offsetLeft;
      let width = button.clientWidth;

      if (isDragging && floor !== ceil) {
        const buttonB = _this8.buttons[ceil];

        if (!buttonB) {
          // the scroll position we received is higher than the max possible position
          // this could happen due to bad CSS (by developer or this module)
          // or bad scrolling logic?
          return;
        }

        const buttonBPosition = buttonB.offsetLeft;
        const buttonBWidth = buttonB.clientWidth;
        position += remainder * (buttonBPosition - position);
        width += remainder * (buttonBWidth - width);
      }

      requestAnimationFrame(() => {
        _this8.indicatorPosition = position;
        _this8.indicatorWidth = width;

        if (_this8.scrollable) {
          _this8.adjustContainerScroll(animate || !isDragging);
        }

        _this8.indicatorEl.style.setProperty('--st-indicator-position-x', _this8.indicatorPosition + 'px');

        _this8.indicatorEl.style.setProperty('--st-indicator-scale-x', String(_this8.indicatorWidth / 100));

        _this8.indicatorEl.style.setProperty('--st-indicator-transition-duration', _this8.isDragging ? '0' : `${_this8.config.transitionDuration}ms`);
      });
    })();
  }
  /**
   * Internal method to output values in debug mode.
   */


  debug(...vals) {
    (0,_utils_640d2cf5_js__WEBPACK_IMPORTED_MODULE_2__.d)(this.config, 'toolbar', vals);
  }

  render() {
    return (0,_index_a34c410e_js__WEBPACK_IMPORTED_MODULE_1__.h)(_index_a34c410e_js__WEBPACK_IMPORTED_MODULE_1__.H, {
      role: "navigation",
      class: this.hostCls
    }, (0,_index_a34c410e_js__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
      class: "buttons-container",
      ref: ref => this.setButtonsContainerEl(ref)
    }, (0,_index_a34c410e_js__WEBPACK_IMPORTED_MODULE_1__.h)("slot", null), this.showIndicator && (0,_index_a34c410e_js__WEBPACK_IMPORTED_MODULE_1__.h)("super-tab-indicator", {
      ref: ref => this.indicatorEl = ref,
      toolbarPosition: this.el.assignedSlot.name
    })));
  }

  get el() {
    return (0,_index_a34c410e_js__WEBPACK_IMPORTED_MODULE_1__.g)(this);
  }

  static get watchers() {
    return {
      "color": ["onColorUpdate"]
    };
  }

}

SuperTabsToolbarComponent.style = superTabsToolbarComponentCss;


/***/ })

}]);
//# sourceMappingURL=node_modules_ionic-super-tabs_core_dist_esm_super-tab-button_2_entry_js.js.map